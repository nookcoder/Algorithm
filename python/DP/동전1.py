from collections import deque 

n, k = map(int, input().split()) 
params = [] 

for _ in range(n): 
    params.append(int(input())) 

dp =  [0 for _ in range(k+1)]
dp[0] = 1

for i in params: 
    for j in range(i, k+1):
        if j-i >= 0:
            dp[j] += dp[j-i]

print(dp[k]) 

# 동적 계획법은 최적화 문제를 해결하는 알고리즘 
# 1. '전체의 문제' 를 '부분 문제' 로 잘 나누었는가? 전체 문제를 해결하기 위한 부분 문제의 점화식은 무엇인가? 
# 부분 문제들을 해결하며 얻는 결과값을 기억해야 하는가? 
# 점화식은 부분 문제들 사이의 '관계' 를 빠짐없이 고려하는가? 

# 동적 계획법 -> 분할 통치법 
# 시간제한이 짧은 경우 

# DP 를 사용하는 이유 
# 1. 중복 로직이 많은 경우 - 알고리즘을 풀 때 재귀를 사용해서 푸는데 같은 로직을 여러 번 반복 -> 비효율적인 계산 
# 2. 큰 문제를 작은 문제로 나눌 수 있을 때 
# 3. 작은 문제에서 구한 정답이 그것을 포함하는 큰 문제에서도 동일한 경우 

# DP 구현하는 방법 
# 1. Memoizartion : 연산은 한 번만 진행해야 한다. 
# - 처음 진행되는 연산인 경우 기록 
# - 이미 진행된 연산인 경우 다시 값을 구하는 게 아니라 기록된 값을 가져옴 

# Bottom-up : 작은 문제부터 차례대로 푸는 방식 (반복문으로 구현)
# 1. 작은 문제부터 차례대로 푼다. 
# 2. 반복해나가면서 큰 문제를 계속 풀어간다. 

# Top-Down : 큰 문제를 작은 문제로 쪼개면서 푸는 문제 (재귀로 구현) 
# 1. 큰 문제를 작은 문제로 나눈다. 
# 2. 작은 문제를 푼다. 
# 3. 푼 작은 문제를 바탕으로 큰 문제를 푼다. 

